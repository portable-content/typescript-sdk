# Portable Content TypeScript SDK

> Framework-agnostic TypeScript SDK for intelligent content rendering and payload source selection

## Overview

The Portable Content TypeScript SDK provides a complete framework-agnostic foundation for rendering content across different platforms (React Native, Vue, React Web, etc.). The core innovation is intelligent payload source selection that automatically chooses optimal content sources based on client capabilities, network conditions, and device characteristics.

## Key Components

### 1. Payload Source Selection Engine (`PayloadSourceSelector`)
Intelligently selects the best payload source from available options:
- **Media type matching** with wildcard support (`image/*`, `*/*`)
- **Quality scoring** based on Accept headers with q-values
- **Format preferences** for modern formats (AVIF > WebP > JPEG)
- **Network optimization** (smaller files on slow/cellular networks)
- **Device awareness** (high-res sources for high-density displays)
- **Source type optimization** (inline vs external based on size and network)

### 2. Renderer System
Framework-agnostic rendering infrastructure:
- **BlockRenderer interface** with priority-based selection
- **RendererRegistry** for managing multiple renderers per block type
- **RenderContext** for passing capabilities and callbacks
- **Base renderer classes** for common functionality

### 3. Content Processing
Content optimization before rendering:
- **Payload source optimization** with fallback selection
- **Representation filtering** for different views (summary, full, etc.)
- **Block-level processing** with individual optimization

### 4. Capability Detection
Automatic client capability detection:
- **Media format support** (WebP, AVIF, SVG detection)
- **Screen characteristics** (dimensions, pixel density)
- **Network conditions** (4G=FAST, 3G=SLOW, 2G=CELLULAR)
- **Server-side safe** with appropriate fallbacks

### 5. Universal Styling System (v0.2.0+)
Framework-agnostic styling with adapter pattern:
- **StyleAdapter interface** for any styling system (CSS-in-JS, utility frameworks, native styling)
- **Universal theme system** with design tokens (colors, spacing, typography, shadows)
- **Adapter registry** for dynamic styling system management
- **Capabilities detection** (responsive, animations, variants, dark mode)
- **Validation & testing** utilities for adapter development
- **Built-in adapters** (BaseStyleAdapter for production, MockStyleAdapter for testing)

## Architecture Principles

1. **Framework Independence**: No UI framework dependencies
2. **Mock-First Development**: Works without backend dependencies
3. **Extensible Design**: Easy to add new block types and renderers
4. **Type Safety**: Full TypeScript support with strict checking
5. **Performance Focus**: Efficient algorithms, minimal bundle size
6. **Styling System Agnostic**: Works with any styling approach via adapters
7. **Three-Layer Architecture**: SDK → Framework Renderers → Styling Adapters

## Usage Patterns

### Basic Payload Source Selection
```typescript
import { PayloadSourceSelector, CapabilityDetector } from '@portable-content/typescript-sdk';

const detector = new CapabilityDetector();
const capabilities = detector.detectCapabilities();

const selector = new PayloadSourceSelector();
const bestSource = selector.selectBestPayloadSource(block, capabilities);
```

### Custom Renderer Implementation
```typescript
import { BaseBlockRenderer } from '@portable-content/typescript-sdk';

class MyRenderer extends BaseBlockRenderer {
  readonly kind = 'markdown';
  readonly priority = 1;

  async render(block, props, context) {
    const payloadSource = this.selectPayloadSource(block, context);
    return {
      content: renderWithMyFramework(payloadSource),
      payloadSource
    };
  }
}
```

### Style Adapter Implementation
```typescript
import { StyleAdapter, Theme } from '@portable-content/typescript-sdk';

class MyStyleAdapter implements StyleAdapter {
  name = 'my-adapter';
  theme: Theme;
  capabilities = { responsive: true, animations: false };

  createStyles(styleDefinition: any): any {
    // Convert generic styles to your system's format
    return convertToMySystem(styleDefinition, this.theme);
  }

  combineStyles(...styles: any[]): any {
    // Merge multiple styles
    return mergeStyles(styles);
  }
}
```

### Content Processing
```typescript
import { DefaultContentProcessor } from '@portable-content/typescript-sdk';

const processor = new DefaultContentProcessor();
const optimized = await processor.processContent(manifest, capabilities);
// Each block now has optimal payload sources selected
```

## Data Models

### Core Types
- **ContentManifest**: Top-level content with blocks and representations
- **Block**: Individual content block with BlockContent structure
- **BlockContent**: Content structure with primary, alternatives, and source payload sources
- **PayloadSource**: Specific content source (inline or external, with media type, URI/source, dimensions, size)
- **Capabilities**: Client capabilities (accept types, hints)

### Rendering Types
- **RenderContext**: Context passed to renderers (capabilities, callbacks)
- **RenderResult**: Result of rendering (content, payloadSource, metadata, errors)
- **BlockRenderer**: Interface for block renderers

## Testing

Comprehensive test suite with 123+ tests:
- **Unit tests** for all components
- **Integration tests** for end-to-end scenarios
- **MockContentFactory** for generating test data
- **Edge case coverage** and error handling

## Framework Integration

The SDK is designed to work with any UI framework:

### React Native
```typescript
class ReactNativeImageRenderer extends BaseImageRenderer {
  async render(block, props, context) {
    const payloadSource = this.selectPayloadSource(block, context);
    const uri = payloadSource.type === 'external' ? payloadSource.uri : payloadSource.source;
    return {
      content: <Image source={{ uri }} {...props} />,
      payloadSource
    };
  }
}
```

### Vue
```typescript
class VueMarkdownRenderer extends BaseTextRenderer {
  async render(block, props, context) {
    const payloadSource = this.selectPayloadSource(block, context);
    const text = await this.getTextContent(payloadSource);
    return {
      content: h('div', { innerHTML: renderMarkdown(text) }),
      payloadSource
    };
  }
}
```

## Performance Characteristics

- **Efficient payload source selection**: O(n) algorithm with smart scoring
- **Network-aware**: Automatically optimizes for connection speed
- **Minimal bundle size**: Tree-shakeable with no UI dependencies
- **Memory efficient**: Processes content in streaming fashion
- **Cache-friendly**: Deterministic payload source selection for consistent caching

## Development Workflow

1. **Mock-first development**: Use MockContentFactory for testing
2. **Type-safe**: Full TypeScript support with strict checking
3. **Test-driven**: Comprehensive test suite with high coverage
4. **Lint-enforced**: ESLint + Prettier for code quality
5. **Build-optimized**: Rollup for efficient bundling

## Extension Points

- **Custom block types**: Implement BlockRenderer interface
- **Custom capability detection**: Extend CapabilityDetector
- **Custom content processing**: Extend ContentProcessor
- **Custom payload source selection**: Extend PayloadSourceSelector
- **Custom styling systems**: Implement StyleAdapter interface
- **Framework renderers**: Build renderers for any UI framework using adapters

## Documentation

Comprehensive guides available in `/docs`:
- **STYLING_SYSTEM.md**: Complete styling system documentation
- **ADAPTER_IMPLEMENTATION_GUIDE.md**: Step-by-step adapter creation
- **INTEGRATION_GUIDE.md**: Renderer and adapter integration patterns
- **COMPLETE_EXAMPLE.md**: Full working example with styled-components
- **RENDERER_GUIDE.md**: Framework-specific renderer implementation

This SDK provides the foundation for building content rendering systems that automatically adapt to client capabilities and deliver optimal user experiences across all platforms.
